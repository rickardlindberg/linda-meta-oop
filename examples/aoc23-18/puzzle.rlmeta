universe Part1 =
    CLI()
    Parser()
    Digger()
    HoleCounter()
    examples
        ["Args" "example.txt"] -> [["Result" 62]]
        ["Args" "input.txt"] -> [["Result" 52231]]

actor CLI =
    "Args" .:input !. -> put(["File" read(input)])

actor Parser =
    "File" [plan:x] !. -> put(x)
    where
        plan        = instruction*:xs !.   -> ["Plan" ~xs]
        instruction =
            direction:d ' '
            number:n ' '
            color:c '\n'
                -> [d n c]
        direction   = 'U' | 'D' | 'L' | 'R'
        number      = digit:x digit*:xs    -> int({ x xs })
        digit       = '0'-'9':x            -> int(x)
        color       = '(' (!')' .)*:xs ')' -> { xs }
    examples
        ["File" "R 9 (#066240)\nU 6 (#113213)\n"] -> [
            ["Plan"
                ["R" 9 "#066240"]
                ["U" 6 "#113213"]
            ]
        ]

actor Digger =
    "Plan" instruction*:xs !.
        -> dict([tuple("x" 0) tuple("y" 0)]):pos
        -> put(["Polygon" render(pos) ~xs])
    where
        instruction =
            | ["U" .:n] -> move(pos 0         negate(n))
            | ["D" .:n] -> move(pos 0         n)
            | ["L" .:n] -> move(pos negate(n) 0)
            | ["R" .:n] -> move(pos n         0)
    examples
        ["Plan"
            ["R" 2 "red"]
            ["D" 2 "green"]
        ] -> [["Polygon"
            tuple(0 0)
            tuple(2 0)
            tuple(2 2)
        ]]

def render pos =
    return (pos["x"], pos["y"])

def move pos dx dy =
    pos["x"] += dx
    pos["y"] += dy
    return render(pos)

def negate x =
    return -1*x

actor HoleCounter =
    "Polygon" .*:xs !. -> put(["Result" countPointsInside(xs)])
    examples
        ["Polygon"
            tuple(0 0) tuple(2 0)
                       tuple(2 2)
            tuple(0 2)
        ] -> [["Result" 9]]

def countPointsInside points =
    def addRangeInner(y, start, end):
        if y not in ranges:
            ranges[y] = []
        ranges[y].append((start, end))
    ranges = {}
    verticals = []
    x1, y1 = points[-1]
    for x2, y2 in points:
        if x1 == x2:
            start = min(y1, y2)
            end = max(y1, y2)
            verticals.append((x1, start, end))
            for y in range(start, end+1):
                addRangeInner(y, x1, x2)
        else:
            assert y1 == y2
            start = min(x1, x2)
            end = max(x1, x2)
            addRangeInner(y1, start, end)
        x1, y1 = x2, y2
    verticals = sorted(verticals, key=lambda x: x[0])
    for y in range(
        min(y for x, y in points),
        max(y for x, y in points)+1
    ):
        insideFlag = False
        last = None
        for at, start, stop in verticals:
            if start < y <= stop:
                if insideFlag:
                    addRangeInner(y, last+1, at-1)
                    last = None
                else:
                    last = at
                insideFlag = not insideFlag
        assert last is None
    count = 0
    for y, r in ranges.items():
        last = None
        for start, end in sorted(r, key=lambda x: x[0]):
            if last is None:
                count += (end - start + 1)
                last = end
            else:
                if end > last:
                    if start <= last:
                        start = last+1
                    count += (end - start + 1)
                    last = end
    return count
