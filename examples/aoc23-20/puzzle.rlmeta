actor Main = "Args" -> selftest()

universe Part1 =
    Reader()
    Parser()
    Augmenter()
    PythonPulseCounter()
    Summer()
    examples
        ["Read" "example.txt"] -> [["Result" 32000000]]
        ["Read" "example2.txt"] -> [["Result" 11687500]]
        ["Read" "input.txt"] -> [["Result" 856482136]]

actor Reader =
    "Read" .:input !. -> put(["File" read(input)])

actor Parser =
    "File" [config:x !.] !. -> put(x)
    where
        config  = module*:xs             -> ["Configuration" ~xs]
        module  = type:t name:x ' -> '
                  targets:xs '\n'        -> [t x xs]
        targets = name:x (', ' name)*:xs -> [x ~xs]
        name    = char:x char*:xs        -> { x xs }
        char    = 'a'-'z'
        type    =
            | '%' -> "FlipFlop"
            | '&' -> "Conjunction"
            |     -> "Module"
    examples
        ["File" {
            "broadcaster -> a, b, c\n"
            "%a -> b\n"
            "%b -> c\n"
            "%c -> inv\n"
            "&inv -> a\n"
        }] -> [["Configuration"
            ["Module" "broadcaster" ["a" "b" "c"]]
            ["FlipFlop" "a" ["b"]]
            ["FlipFlop" "b" ["c"]]
            ["FlipFlop" "c" ["inv"]]
            ["Conjunction" "inv" ["a"]]
        ]]

actor Augmenter =
    "Configuration" module*:xs
        -> dict():ins
        -> []:present
        -> []:empties
        -> put(["Program" ~xs ~generateEmpties(present empties ins)])
    where
        module = [.:type .:name [out*:outs]]
            -> append(present name)
            -> name:fromName
            -> [type name readIn(ins name) outs]
        out = .:toName
            -> append(empties toName)
            -> registerTransition(ins fromName toName)
            -> toName
    examples
        ["Configuration"
            ["Module" "broadcaster" ["a" "b"]]
            ["FlipFlop" "a" ["b"]]
            ["FlipFlop" "b" ["inv"]]
            ["Conjunction" "inv" ["a"]]
        ] -> [
            ["Program"
                ["Module"      "broadcaster" []                    ["a" "b"]]
                ["FlipFlop"    "a"           ["broadcaster" "inv"] ["b"]]
                ["FlipFlop"    "b"           ["broadcaster" "a"]   ["inv"]]
                ["Conjunction" "inv"         ["b"]                 ["a"]]
            ]
        ]
        ["Configuration"
            ["Module" "broadcaster" ["a" "b"]]
            ["FlipFlop" "a" ["b"]]
        ] -> [
            ["Program"
                ["Module"   "broadcaster" []                  ["a" "b"]]
                ["FlipFlop" "a"           ["broadcaster"]     ["b"]]
                ["Empty"    "b"           ["broadcaster" "a"] []]
            ]
        ]

actor ExecutionPreparer =
    | "Program" initModule*:xs !.
        -> dict():modules
        -> dict():state
        -> xs
        -> put(["Execution"
            state
            0
            0
            0
            modules
        ])
    where
        initModule =
            | ["Module" .:name . .:outs]
                -> dictSet(modules name ["Module" outs])
            | ["FlipFlop" .:name . .:outs]
                -> dictSet(modules name ["FlipFlop" outs])
                -> dictSet(state name "off")
            | ["Conjunction" .:name [initIn*:ins] .:outs]
                -> dictSet(modules name ["Conjunction" outs])
                -> name:name
                -> ins
            | ["Empty" .:name]
                -> dictSet(modules name ["Empty" []])
        initIn = .:x -> dictSet(state tuple([name x]) "low")
    examples
        ["Program"
            ["Module"   "broadcaster" []                  ["a" "b"]]
            ["FlipFlop" "a"           ["broadcaster"]     ["b"]]
            ["Empty"    "b"           ["broadcaster" "a"] []]
        ] -> [[
            "Execution"
            dict([
                ["a" "off"]
            ])
            0
            0
            0
            dict([
                ["broadcaster" ["Module" ["a" "b"]]]
                ["a"           ["FlipFlop" ["b"]]]
                ["b"           ["Empty" []]]
            ])
        ]]

actor PythonPulseCounter =
    | "Program" .*:xs !. -> put(doPythonPulse(xs))

def dictSet dict name value =
    dict[name] = value

def doPythonPulse modules =
    flipFlopStates = {}
    conjunctionValues = {}
    byName = {}
    for type, name, ins, outs in modules:
        byName[name] = {
            "name": name,
            "type": type,
            "ins": ins,
            "outs": outs,
        }
        if type == "FlipFlop":
            flipFlopStates[name] = "off"
        elif type == "Conjunction":
            for inName in ins:
                conjunctionValues[(name, inName)] = "low"
    runtime = {"sumLow": 0, "sumHigh": 0}
    for i in range(1000):
        evalStatements(
            compileProgram(
                [("-", "low", "broadcaster")],
                byName,
                flipFlopStates,
                conjunctionValues
            ),
            flipFlopStates,
            conjunctionValues,
            runtime
        )
    return ["Result", runtime["sumLow"]*runtime["sumHigh"]]

def evalStatements statements flipFlopStates conjunctionValues runtime =
    for statement in statements:
        if statement[0] == "Send":
            if statement[1] == "high":
                runtime["sumHigh"] += 1
            else:
                runtime["sumLow"] += 1
        elif statement[0] == "IfOn":
            _, name, onBranch, offBranch = statement
            if flipFlopStates[name] == "on":
                evalStatements(onBranch, flipFlopStates, conjunctionValues, runtime)
            else:
                evalStatements(offBranch, flipFlopStates, conjunctionValues, runtime)
        elif statement[0] == "SetFlipFlop":
            _, name, value = statement
            flipFlopStates[name] = value
        elif statement[0] == "IfAllHigh":
            _, names, allHighBranch, someLowBranch = statement
            if set(conjunctionValues[x] for x in names) == {"high"}:
                evalStatements(allHighBranch, flipFlopStates, conjunctionValues, runtime)
            else:
                evalStatements(someLowBranch, flipFlopStates, conjunctionValues, runtime)
        elif statement[0] == "RegisterConjunction":
            _, name, value = statement
            conjunctionValues[name] = value
        else:
            raise ValueError(f"invalid statement {statement}")

def compileProgram signals byName flipFlopStates conjunctionValues =
    signals = list(signals)
    statements = []
    while signals:
        fromNode, signal, toNode = signals.pop(0)
        assert signal in ["low", "high"]
        statements.append(["Send", signal, toNode])
        module = byName[toNode]
        if module["type"] == "Module":
            for outName in module["outs"]:
                signals.append((module["name"], signal, outName))
        elif module["type"] == "FlipFlop":
            if signal == "low":
                if module["name"] in flipFlopStates:
                    if flipFlopStates[module["name"]] == "on":
                        newSignal = "low"
                        flipFlopStates = dict(flipFlopStates, **{module["name"]: "off"})
                        statements.append(["SetFlipFlop", module["name"], "off"])
                    else:
                        assert flipFlopStates[module["name"]] == "off"
                        newSignal = "high"
                        flipFlopStates = dict(flipFlopStates, **{module["name"]: "on"})
                        statements.append(["SetFlipFlop", module["name"], "on"])
                    for outName in module["outs"]:
                        signals.append((module["name"], newSignal, outName))
                else:
                    raise ValueError("no flipflop not supported")
        elif module["type"] == "Conjunction":
            statements.append(["RegisterConjunction", (module["name"], fromNode), signal])
            conjunctionValues = dict(conjunctionValues)
            conjunctionValues[(module["name"], fromNode)] = signal
            if set([
                conjunctionValues[(module["name"], inName)]
                for inName in module["ins"]
            ]) == {"high"}:
                newSignal = "low"
            else:
                newSignal = "high"
            for outName in module["outs"]:
                signals.append((module["name"], newSignal, outName))
        else:
            assert module["type"] == "Empty"
    return statements

actor PulseCounter #times =
    | "Program" module*:xs !.
        -> put(["Pulser" [["broadcaster" "low" "-"]] times dict([~~xs]) 0 0])
    | "Pulser" [!.] 1       .:state .:low .:high !.
        -> put(["Pulses" low high])
    | "Pulser" [!.] .:times .:state .:low .:high !.
        -> put(["Pulser" [["broadcaster" "low" "-"]] sub(times 1) state low high])
    where
        module =
            | ["Module" .:name . .:outs]
                -> spawn(Forwarder(name outs))
                -> []
            | ["FlipFlop" .:name . .:outs]
                -> spawn(FlipFlopper(name outs))
                -> [[name "off"]]
            | ["Conjunction" .:name [in*:ins] .:outs]
                -> spawn(Conjunctitoner(name outs))
                -> [[name dict(ins)]]
            | ["Empty" .:name]
                -> spawn(Emptier(name))
                -> []
        in = .:x -> [x "low"]
    universe PulseCounter1 =
        PulseCounter(1)
        examples
            ["Program"
                ["Module" "broadcaster" [] ["a"]]
                ["FlipFlop" "a" ["broadcaster"] ["a"]]
            ] -> [
                ["Pulses" 2 1]
            ]

actor Forwarder #name #outs =
    | "Pulser" [[#name "low"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               [~xs ~pulseOut(outs "low" name)]
               times
               state
               add(low 1)
               high
           ])
    | "Pulser" [[#name "high"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               [~xs ~pulseOut(outs "high" name)]
               times
               state
               low
               add(high 1)
           ])

actor FlipFlopper #name #outs =
    | "Pulser" [[#name "low"] .*:xs] .:times .:state .:low .:high !.
        -> flip(state name outs):x
        -> put(["Pulser"
               [~xs ~get(x "pulses")]
               times
               get(x "state")
               add(low 1)
               high
           ])
    | "Pulser" [[#name "high"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser" xs times state low add(high 1)])

actor Conjunctitoner #name #outs =
    | "Pulser" [[#name .:pulse .:sender] .*:xs] .:times .:state .:low .:high !.
        -> conjure(state name outs sender pulse):x
        -> put(["Pulser"
               [~xs ~get(x "pulses")]
               times
               get(x "state")
               add(low get(x "lowCount"))
               add(high get(x "highCount"))
           ])

actor Emptier #name =
    | "Pulser" [[#name "low"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               xs
               times
               state
               add(low 1)
               high
           ])
    | "Pulser" [[#name "high"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               xs
               times
               state
               low
               add(high 1)
           ])

actor Summer =
    "Pulses" .:low .:high -> put(["Result" mul(low high)])

def generateEmpties present empties ins =
    return [
        ["Empty", x, readIn(ins, x), []]
        for x in set(empties) if x not in present
    ]

def append list item =
    list.append(item)

def conjure state name outs sender pulse =
    newLast = dict(state[name], **{sender: pulse})
    lowCount = 0
    highCount = 0
    if pulse == "high":
        highCount = 1
    else:
        assert pulse == "low"
        lowCount = 1
    if set(newLast.values()) == {"high"}:
        newPulse = "low"
    else:
        newPulse = "high"
    return {
        "state": dict(state, **{name: newLast}),
        "lowCount": lowCount,
        "highCount": highCount,
        "pulses": pulseOut(outs, newPulse, name),
    }

def add x y =
    return x + y

def sub x y =
    return x - y

def mul x y =
    return x * y

def flip state name outs =
    if state[name] == "on":
        pulse = "low"
        flipped = "off"
    elif state[name] == "off":
        pulse = "high"
        flipped = "on"
    else:
        raise ValueError("invalid state")
    return {
        "state": dict(state, **{name: flipped}),
        "pulses": pulseOut(outs, pulse, name),
    }

def pulseOut outs pulse sender =
    return [[out, pulse, sender] for out in outs]

def get dict name =
    return dict[name]

def readIn ins name =
    if name not in ins:
        ins[name] = []
    return ins[name]

def registerTransition ins fromName toName =
    if toName not in ins:
        ins[toName] = []
    ins[toName].append(fromName)
