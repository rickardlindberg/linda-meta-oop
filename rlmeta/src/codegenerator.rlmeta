CodeGenerator {
  run           = "Ast" .:p [asts:x]     -> put(["Part" p x])
  asts          = ast*:xs !.             -> { xs                                         }
  ast           = [%:x !.]               -> x
  Actor         = .:x ast*:ys            -> []:ids                                              ->
                                            []:matchers                                         ->
                                            []:rules                                            ->
                                            { ys
                                              "class " x ":\n" indent({
                                                "def __init__(self, n=None):\n" indent({
                                                  "self._state = {'n': n}\n"
                                                  "self._rules = {\n" indent({ rules }) "}\n"
                                                 })
                                                "def run(self, stream):\n" indent({
                                                  "return self._rules['run'](stream)\n"
                                                 })
                                                matchers
                                              })
                                            }
  Rule          = .:x ast:y              -> append(rules {repr(x) ": " y ",\n"}) -> ""
  Or            = matcher:m astList:x    -> { "stream.operator_or([" x "])"              }:body -> m
  Scope         = matcher:m ast:x        -> { "stream.with_scope(" x ")"                 }:body -> m
  And           = matcher:m astList:x    -> { "stream.operator_and([" x "])"             }:body -> m
  Bind          = matcher:m repr:x ast:y -> { "stream.bind(" x ", " y "(stream))"        }:body -> m
  Star          = matcher:m ast:x        -> { "stream.operator_star(" x ")"              }:body -> m
  Not           = matcher:m ast:x        -> { "stream.operator_not(" x ")"               }:body -> m
  MatchCallRule = matcher:m              -> { "stream.match_call_rule(self._rules)"      }:body -> m
  MatchRule     = matcher:m .:x          -> { "self._rules['" x "'](stream)"             }:body -> m
  MatchObject   = matcher:m ast:x        -> { "stream.match(lambda item: " x ")"         }:body -> m
  MatchList     = matcher:m ast:x        -> { "stream.match_list(" x ")"                 }:body -> m
  Action        = matcher:m ast:x        -> { "stream.action(lambda self: " x ")"        }:body -> m
  Any           =                        -> { "True"             ", 'any'"               }
  State         = repr:x                 -> { "item == self._state[" x "], 'state'"      }
  Eq            = repr:x                 -> { "item == " x       ", " repr(x)            }
  Range         = repr:x repr:y          -> { x " <= item <= " y ", \"" x "-" y "\""     }
  Set           = repr:x ast:y ast:z     -> { "self.bind(" x ", " y ", lambda: " z ")"   }
  String        = repr
  Number        = repr
  List          = astList:x              -> { "self.lookup('concat')([" x "])"           }
  ListItem      = repr:x ast:y           -> { "self.lookup('splice')(" x ", " y ")"      }
  Format        = astList:x              -> { "self.lookup('join')([" x "])"             }
  Call          = ast:x astList:y        -> { x "(" y ")"                                }
  Lookup        = repr:x                 -> { "self.lookup(" x ")"                       }
  astList       = ast*:xs                -> { "\n" indent(join(xs ",\n")) "\n"           }
  matcher       =                        -> { "_matcher_" len(ids)                       }:id ->
                                            append(ids id)                                    ->
                                            append(matchers { "def " id "(self, stream):\n" indent({
                                                "return " body "\n"
                                              })
                                            })                                                ->
                                            { "self." id }
  repr          = .:x                    -> repr(x)
}
