universe Part1 =
    CLI()
    Parser()
    Augmenter()
    PythonPulseCounter(1)
    Summer()
    examples
        ["Args" "example.txt"] -> [["Result" 32000000]]
        ["Args" "example2.txt"] -> [["Result" 11687500]]
        ["Args" "input.txt"] -> [["Result" 856482136]]

universe Part2 =
    CLI()
    Parser()
    Augmenter()
    PythonPulseCounter(2)
    Summer()
    examples
        ["Args" "input.txt"] -> [["Result" 0]]

actor CLI =
    "Args" .:input !. -> put(["File" read(input)])

actor Parser =
    "File" [config:x !.] !. -> put(x)
    where
        config  = module*:xs             -> ["Configuration" ~xs]
        module  = type:t name:x ' -> '
                  targets:xs '\n'        -> [t x xs]
        targets = name:x (', ' name)*:xs -> [x ~xs]
        name    = char:x char*:xs        -> { x xs }
        char    = 'a'-'z'
        type    =
            | '%' -> "FlipFlop"
            | '&' -> "Conjunction"
            |     -> "Module"
    examples
        ["File" {
            "broadcaster -> a, b, c\n"
            "%a -> b\n"
            "%b -> c\n"
            "%c -> inv\n"
            "&inv -> a\n"
        }] -> [["Configuration"
            ["Module" "broadcaster" ["a" "b" "c"]]
            ["FlipFlop" "a" ["b"]]
            ["FlipFlop" "b" ["c"]]
            ["FlipFlop" "c" ["inv"]]
            ["Conjunction" "inv" ["a"]]
        ]]

actor Augmenter =
    "Configuration" module*:xs
        -> dict():ins
        -> []:present
        -> []:empties
        -> put(["Program" ~xs ~generateEmpties(present empties ins)])
    where
        module = [.:type .:name [out*:outs]]
            -> append(present name)
            -> name:fromName
            -> [type name readIn(ins name) outs]
        out = .:toName
            -> append(empties toName)
            -> registerTransition(ins fromName toName)
            -> toName
    examples
        ["Configuration"
            ["Module" "broadcaster" ["a" "b"]]
            ["FlipFlop" "a" ["b"]]
            ["FlipFlop" "b" ["inv"]]
            ["Conjunction" "inv" ["a"]]
        ] -> [
            ["Program"
                ["Module"      "broadcaster" []                    ["a" "b"]]
                ["FlipFlop"    "a"           ["broadcaster" "inv"] ["b"]]
                ["FlipFlop"    "b"           ["broadcaster" "a"]   ["inv"]]
                ["Conjunction" "inv"         ["b"]                 ["a"]]
            ]
        ]
        ["Configuration"
            ["Module" "broadcaster" ["a" "b"]]
            ["FlipFlop" "a" ["b"]]
        ] -> [
            ["Program"
                ["Module"   "broadcaster" []                  ["a" "b"]]
                ["FlipFlop" "a"           ["broadcaster"]     ["b"]]
                ["Empty"    "b"           ["broadcaster" "a"] []]
            ]
        ]

actor PythonPulseCounter #part =
    | "Program" .*:xs !. -> put(doPythonPulse(part xs))

def doPythonPulse part modules =
    flipFlopStates = {}
    conjunctionValues = {}
    byName = {}
    for type, name, ins, outs in modules:
        byName[name] = {
            "name": name,
            "type": type,
            "ins": ins,
            "outs": outs,
        }
        if type == "FlipFlop":
            flipFlopStates[name] = "off"
        elif type == "Conjunction":
            for inName in ins:
                conjunctionValues[(name, inName)] = "low"
    if part == 1:
        sumLow = 0
        sumHigh = 0
        for i in range(1000):
            sumLowX, sumHighX = evalStatements(
                compileProgram(
                    [("-", "low", "broadcaster")],
                    byName,
                    flipFlopStates,
                    conjunctionValues
                ),
                flipFlopStates,
                conjunctionValues
            )
            sumLow += sumLowX
            sumHigh += sumHighX
        return ["Result", sumLow*sumHigh]
    else:
        return ["Result", 0]

def evalStatements statements flipFlopStates conjunctionValues =
    sumLow = 0
    sumHigh = 0
    for statement in statements:
        if statement[0] == "Send":
            _, signal, toNode = statement
            if signal == "high":
                sumHigh += 1
            else:
                sumLow += 1
    return (sumLow, sumHigh)

def compileProgram signals byName flipFlopStates conjunctionValues =
    statements = list(signals)
    while signals:
        fromNode, signal, toNode = signals.pop(0)
        assert signal in ["low", "high"]
        statements.append(["Send", signal, toNode])
        module = byName[toNode]
        if module["type"] == "Module":
            for outName in module["outs"]:
                signals.append((module["name"], signal, outName))
        elif module["type"] == "FlipFlop":
            if signal == "low":
                if module["name"] in flipFlopStates:
                    if flipFlopStates[module["name"]] == "on":
                        newSignal = "low"
                        flipFlopStates[module["name"]] = "off"
                    else:
                        assert flipFlopStates[module["name"]] == "off"
                        newSignal = "high"
                        flipFlopStates[module["name"]] = "on"
                    for outName in module["outs"]:
                        signals.append((module["name"], newSignal, outName))
                else:
                    raise ValueError("no flipflop not supported")
        elif module["type"] == "Conjunction":
            conjunctionValues[(module["name"], fromNode)] = signal
            if set([
                conjunctionValues[(module["name"], inName)]
                for inName in module["ins"]
            ]) == {"high"}:
                newSignal = "low"
            else:
                newSignal = "high"
            for outName in module["outs"]:
                signals.append((module["name"], newSignal, outName))
        else:
            assert module["type"] == "Empty"
    return statements

actor PulseCounter #times =
    | "Program" module*:xs !.
        -> put(["Pulser" [["broadcaster" "low" "-"]] times dict([~~xs]) 0 0])
    | "Pulser" [!.] 1       .:state .:low .:high !.
        -> put(["Pulses" low high])
    | "Pulser" [!.] .:times .:state .:low .:high !.
        -> put(["Pulser" [["broadcaster" "low" "-"]] sub(times 1) state low high])
    where
        module =
            | ["Module" .:name . .:outs]
                -> spawn(Forwarder(name outs))
                -> []
            | ["FlipFlop" .:name . .:outs]
                -> spawn(FlipFlopper(name outs))
                -> [[name "off"]]
            | ["Conjunction" .:name [in*:ins] .:outs]
                -> spawn(Conjunctitoner(name outs))
                -> [[name dict(ins)]]
            | ["Empty" .:name]
                -> spawn(Emptier(name))
                -> []
        in = .:x -> [x "low"]
    universe PulseCounter1 =
        PulseCounter(1)
        examples
            ["Program"
                ["Module" "broadcaster" [] ["a"]]
                ["FlipFlop" "a" ["broadcaster"] ["a"]]
            ] -> [
                ["Pulses" 2 1]
            ]

actor Forwarder #name #outs =
    | "Pulser" [[#name "low"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               [~xs ~pulseOut(outs "low" name)]
               times
               state
               add(low 1)
               high
           ])
    | "Pulser" [[#name "high"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               [~xs ~pulseOut(outs "high" name)]
               times
               state
               low
               add(high 1)
           ])

actor FlipFlopper #name #outs =
    | "Pulser" [[#name "low"] .*:xs] .:times .:state .:low .:high !.
        -> flip(state name outs):x
        -> put(["Pulser"
               [~xs ~get(x "pulses")]
               times
               get(x "state")
               add(low 1)
               high
           ])
    | "Pulser" [[#name "high"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser" xs times state low add(high 1)])

actor Conjunctitoner #name #outs =
    | "Pulser" [[#name .:pulse .:sender] .*:xs] .:times .:state .:low .:high !.
        -> conjure(state name outs sender pulse):x
        -> put(["Pulser"
               [~xs ~get(x "pulses")]
               times
               get(x "state")
               add(low get(x "lowCount"))
               add(high get(x "highCount"))
           ])

actor Emptier #name =
    | "Pulser" [[#name "low"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               xs
               times
               state
               add(low 1)
               high
           ])
    | "Pulser" [[#name "high"] .*:xs] .:times .:state .:low .:high !.
        -> put(["Pulser"
               xs
               times
               state
               low
               add(high 1)
           ])

actor Summer =
    "Pulses" .:low .:high -> put(["Result" mul(low high)])

def generateEmpties present empties ins =
    return [
        ["Empty", x, readIn(ins, x), []]
        for x in set(empties) if x not in present
    ]

def append list item =
    list.append(item)

def conjure state name outs sender pulse =
    newLast = dict(state[name], **{sender: pulse})
    lowCount = 0
    highCount = 0
    if pulse == "high":
        highCount = 1
    else:
        assert pulse == "low"
        lowCount = 1
    if set(newLast.values()) == {"high"}:
        newPulse = "low"
    else:
        newPulse = "high"
    return {
        "state": dict(state, **{name: newLast}),
        "lowCount": lowCount,
        "highCount": highCount,
        "pulses": pulseOut(outs, newPulse, name),
    }

def add x y =
    return x + y

def sub x y =
    return x - y

def mul x y =
    return x * y

def flip state name outs =
    if state[name] == "on":
        pulse = "low"
        flipped = "off"
    elif state[name] == "off":
        pulse = "high"
        flipped = "on"
    else:
        raise ValueError("invalid state")
    return {
        "state": dict(state, **{name: flipped}),
        "pulses": pulseOut(outs, pulse, name),
    }

def pulseOut outs pulse sender =
    return [[out, pulse, sender] for out in outs]

def get dict name =
    return dict[name]

def readIn ins name =
    if name not in ins:
        ins[name] = []
    return ins[name]

def registerTransition ins fromName toName =
    if toName not in ins:
        ins[toName] = []
    ins[toName].append(fromName)
